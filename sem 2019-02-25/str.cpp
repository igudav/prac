#include <glob.h>
#include <string.h>
#include <malloc.h>
#include <algorithm>
#include <iostream>

using namespace std;

/*
 * У такого подхода есть минусы:
 * Забывают инициализировать данные => мусор вместо данных
 */

int size;

struct String // если struct, то по умолчанию все поля public, если class, то все private
{
private:
    size_t size; // без инициализации
    size_t size1{}; // инициализация по умолчанию (нулем)
    char *str{};
    int count{}; // добавил поле -- не забудь проинициализировать!!!

public:
    // конструктор по-умолчанию. Вызывается, когда объект создается без параметров
    String() // String *this
    {

        int size; // тогда либо нало явно писать this, либо область видимости
        this->size = 0;
        String::size = 0; // указываем конкретную область видимости
        size = 0; // локальная переменная!!!
        ::size = 0; // глобальная неименованная область видимости

        // новое слово для нулевого указателя, тип nullptr_t, приводим к любому типу указателей
        str = nullptr; // можно опускать this
        printf("String()\n");
    }

    // компилятор умеет сам генерить конструктор по умолчанию, но только если нет других конструкторов
    // String() = default; в таком случае этой строкой мы заставляем компилястер все же сделать конструктор
    // по умолчанию

    String(const char *str)
    {
        if (str) {
            String::size = strlen(str);
            String::str = new char[String::size + 1]; // дописывает 0 байт для системных вызовов
            memcpy(String::str, str, String::size + 1); // для С++ не гуд, лучше stdcopy
        }
    }

    // String(const String &s) = delete; // запрещаем копирование вообще
    // String(const String &s) = default; // конструктор копирования по умолчанию. Он итак генерируется всегда
    // &s - ссылка это как указатель, но другое. Ссылку не нужно разыменовывать. Ссылка не мб нулевой.
    // const int &z - константная ссылка. Ее нельзя модифицировать. Смысл: константная ссылка
    //       не отличима от значения. Везде, где она использутся, можно использовать тупо значение по ссылке.

    String(const String &s) : size{s.size}, str{s.str} // скрытый String *this, const String &s
    {
        /*
        size = s.size;
        str = s.str;
        */
        if (str) {
            str = new char[size + 1];
            memcpy(str, s.str, size + 1);
        }
    } // после : - список инициализации, а тут мы ее перекрываем. Можно задать НУЖНЫЙ конструктор
      // вложенного объекта

    ~String() // деструктор, всегда без аргументов
    {
        if (str) {
            printf("%s\n", str);
        } else {
            printf("null\n");
        }
        delete[] str; // важно использовать delete с кв скобками, так как зедсь
        // выделяется массив
        // нормально обрабатывает нулевой указатель, можно не проверять
    }

    void swap(String &s)
    {
        std::swap(size, s.size);
        std::swap(str, s.str);
    }

    // copy-and-swap
    String &operator =(String s) // тут вызывается конструктор копирования и деструктор автоматически
    {
        swap(s); // избегаем дублирование кода
        // побочный эффект: при присваивании самому себе будет неэффективно
        return *this;
    }

    // String &operator =(const String &s) = delete; // запрещаем присваивание с концами
    /*
    String &operator =(const String &s) // конструктор присваивания, перегрузка оператора
    {
        // проверяем на присваивание самому себе
        if (this == &s) {
            return *this;
        }

        delete[] str; // дублирование кода, но явно вызывать конструктор и деструктор нельзя
                        // из-за ограничений языка
        str = s.str;
        size = s.size;
        if (str) {
            str = new char[size + 1];
            memcpy(str, s.str, size + 1);
        }

        return *this; // * не играет никакой роли, просто для согласования типов. Приводим указатель к ссылке
    }
     */

    size_t get_size() const // константный метод => this имеет тип const String *
                            // а также его можно вызывать для константного объекта
    {
        return size;
    }

    const char *c_str() const
    {
        return str;
    }

    /*void append(char c) {}
    void append(int cnt, char c) {}
    void append(const char cc) {}
    void append(String &s)*/

    // Но нельзя писать s[] = что-то; это read-only вариант
    char operator[] (size_t index) const
    {
        return str[index];
    }

    // А теперь так можно. Компилястер решит сам
    char &operator[] (size_t index)
    {
        return str[index];
    }

    // А если честная двумерная матрица? Как перегружать, чтобы x[i][j]?
    // Тогда все операции, кроме последней, возвращают прокси-класс (вспомогательный),
    // которы только и умеет, что разыменовывать дальше.

    String &operator +=(char c)
    {
        // append(c);
        return *this;
    }
};
/*
void init_string(String *dst, const char *str)
{
    dst->str = strdup("abc");
    dst->size = 3;
}
*/

String s2; //перед кодом main отрабатывают конструкторы глобальных переменных в неопределенном порядке

/*
String f(String str)
{
    printf("!!!!%s\n", str.str);
    return String{"from f"}; // и здесь конструктор копирования
}
*/

int main()
{
    // такие конструкции будут размазываться по коду
    String s1;
    /*
    s1.str = strdup("abc");
    s1.size = 3;
    */

    String *s3 = new String; // на куче

    String s5[16]; // выделится на стеке память под 16 структур, для каждого будет вызван конструктор.

    String *s6 = new String[8]; // на куче

    // когда будет вызван конструктор? Тогда, когда управление в 1 раз попадет в эту точку
    if (s1.get_size() == 123) {
        static String s7; // конструктор вызван не будет.
    }

    // атомарность операций: либо проинициализирован, либо не создан вообще

    // как вызвать конструктор с параметрами?
    String s8("abc");
    String s9 = String("xxx");
    String s10{"xx1"};

    // деструкторы вызываются в порядке, обратном порядку вызова конструкторов.
    // для глобальных дестрокутор вызывается после того, как отработает main
    // статические тоже

    // если выделяем new, то и удалять надо явно, с помощью delete
    delete[] s6;
    delete s3;
    //f(s8); // тут возникает конструктор копирования
    String s11 = s9; // здесь тоже

    // вариант - запретить копировани
    s11 = s8; // присваивание по умолчанию работает как коприрование. Проблема - один и тот же указатель
    // в динамическую память

    String s7{"qwer"};
    cout << s7[0] << endl;
    s7[0] = 'w';
    cout << s7[0] << endl << endl << endl;

}